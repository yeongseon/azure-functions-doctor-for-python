{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\ude7a Azure Functions Doctor","text":"<p>Welcome to Azure Functions Doctor \u2014 a powerful diagnostic CLI tool built with Python to help you validate and troubleshoot your local Azure Functions environment.</p>"},{"location":"#what-is-it","title":"What Is It?","text":"<p>Azure Functions Doctor analyzes your project folder and environment to detect:</p> <ul> <li>Missing configuration files (e.g., <code>host.json</code>, <code>requirements.txt</code>)</li> <li>Unsupported Python versions</li> <li>Missing dependencies (e.g., <code>azure-functions</code>)</li> <li>Broken or misnamed function folders</li> <li>Other common issues that break Azure Functions locally or in CI/CD</li> </ul> <p>It provides clear emoji-based output, rule-based extensibility, and optional JSON formatting.</p>"},{"location":"#when-should-you-use-this","title":"When Should You Use This?","text":"Scenario Usefulness Developing locally Quickly catch broken setup before you run <code>func start</code> \ud83d\udea2 Before deployment Prevent silent 500 errors caused by bad config \ud83d\udd01 In CI pipeline Automate validation across repos and branches Debugging errors Eliminate basic mistakes before diving into logs"},{"location":"#quick-start","title":"\ud83e\uddf0 Quick Start","text":"<pre><code>pip install azure-functions-doctor\nfunc-doctor diagnose\n</code></pre> <p>View Usage Guide \u2192 See Example Project \u2192</p>"},{"location":"#documentation-overview","title":"\ud83d\udcd8 Documentation Overview","text":"Topic Description Usage Guide How to run and interpret results Rule System Understand and customize <code>rules.json</code> Diagnostics Reference Full list of built-in checks Developer Guide Contribute and extend the CLI Release Process Versioning and PyPI publishing"},{"location":"#need-help","title":"\ud83d\udcac Need Help?","text":"<p>Feel free to open an issue or check out our GitHub Discussions.</p>"},{"location":"#example-output","title":"Example Output","text":""},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"api/","title":"\ud83e\udde0 API Reference","text":""},{"location":"api/#cli","title":"CLI","text":""},{"location":"api/#azure_functions_doctor.cli.diagnose","title":"<code>diagnose(path='.', verbose=False, debug=False, format='table', output=None)</code>","text":"<p>Run diagnostics on an Azure Functions application.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Azure Functions app. Defaults to current directory.</p> <code>'.'</code> <code>verbose</code> <code>bool</code> <p>Show detailed hints for failed checks.</p> <code>False</code> <code>debug</code> <code>Annotated[bool, Option(help='Enable debug logging')]</code> <p>Enable debug logging to stderr.</p> <code>False</code> <code>format</code> <code>Annotated[str, Option(help=\"Output format: 'table' or 'json'\")]</code> <p>Output format: 'table' or 'json'.</p> <code>'table'</code> <code>output</code> <code>Annotated[Optional[Path], Option(help='Optional path to save JSON result')]</code> <p>Optional file path to save JSON result.</p> <code>None</code> Source code in <code>src/azure_functions_doctor/cli.py</code> <pre><code>@cli.command()\ndef diagnose(\n    path: str = \".\",\n    verbose: bool = False,\n    debug: Annotated[bool, typer.Option(help=\"Enable debug logging\")] = False,\n    format: Annotated[str, typer.Option(help=\"Output format: 'table' or 'json'\")] = \"table\",\n    output: Annotated[Optional[Path], typer.Option(help=\"Optional path to save JSON result\")] = None,\n) -&gt; None:\n    \"\"\"\n    Run diagnostics on an Azure Functions application.\n\n    Args:\n        path: Path to the Azure Functions app. Defaults to current directory.\n        verbose: Show detailed hints for failed checks.\n        debug: Enable debug logging to stderr.\n        format: Output format: 'table' or 'json'.\n        output: Optional file path to save JSON result.\n    \"\"\"\n    # Configure logging based on CLI flags\n    if debug:\n        setup_logging(level=\"DEBUG\", format_style=\"structured\")\n    elif verbose:\n        setup_logging(level=\"INFO\", format_style=\"simple\")\n    else:\n        # Use environment variable or default to WARNING\n        setup_logging(level=None, format_style=\"simple\")\n\n    start_time = time.time()\n    doctor = Doctor(path)\n    resolved_path = Path(path).resolve()\n\n    # Log diagnostic start\n    rules = doctor.load_rules()\n    log_diagnostic_start(str(resolved_path), len(rules))\n\n    results = doctor.run_all_checks()\n\n    # Calculate execution metrics\n    end_time = time.time()\n    duration_ms = (end_time - start_time) * 1000\n\n    # Count results for logging\n    total_checks = sum(len(section[\"items\"]) for section in results)\n    passed_items = sum(1 for section in results for item in section[\"items\"] if item[\"status\"] == \"pass\")\n    failed_items = sum(1 for section in results for item in section[\"items\"] if item[\"status\"] == \"fail\")\n    errors = sum(1 for section in results for item in section[\"items\"] if item[\"status\"] == \"error\")\n\n    # Log diagnostic completion\n    log_diagnostic_complete(total_checks, passed_items, failed_items, errors, duration_ms)\n\n    passed = failed = 0\n\n    if format == \"json\":\n        json_output = results\n\n        if output:\n            output.parent.mkdir(parents=True, exist_ok=True)\n            output.write_text(json.dumps(json_output, indent=2), encoding=\"utf-8\")\n            console.print(f\"[green]\u2713 JSON output saved to:[/green] {output}\")\n        else:\n            print(json.dumps(json_output, indent=2))\n        return\n\n    # Print header only for table format\n    console.print(f\"[bold blue]\ud83e\ude7a Azure Functions Doctor for Python v{__version__}[/bold blue]\")\n    console.print(f\"[bold]\ud83d\udcc1 Path:[/bold] {resolved_path}\\n\")\n\n    if debug:\n        console.print(\"[dim]Debug logging enabled - check stderr for detailed logs[/dim]\\n\")\n\n    # Default: table format\n    for section in results:\n        console.print(Text.assemble(\"\\n\", format_result(section[\"status\"]), \" \", (section[\"title\"], \"bold\")))\n\n        if section[\"status\"] == \"pass\":\n            passed += 1\n        else:\n            failed += 1\n\n        for item in section[\"items\"]:\n            label = item[\"label\"]\n            value = item[\"value\"]\n            status = item[\"status\"]\n\n            line = Text.assemble(\n                (\"  \u2022 \", \"default\"),\n                (label, \"dim\"),\n                (\": \", \"default\"),\n                format_detail(status, value),\n            )\n            console.print(line)\n\n            if verbose and status != \"pass\":\n                if item.get(\"hint\"):\n                    console.print(f\"    \u21aa [yellow]{item['hint']}[/yellow]\")\n                hint_url = item.get(\"hint_url\", \"\")\n                if hint_url.strip():\n                    console.print(f\"    \ud83d\udcda [blue]{hint_url}[/blue]\")\n\n    # \u2705 Summary section\n    console.print()\n    console.print(\"[bold]Summary[/bold]\")\n    summary = Text.assemble(\n        (f\"{format_status_icon('pass')} \", \"green bold\"),\n        (f\"{passed} Passed    \", \"bold\"),\n        (f\"{format_status_icon('fail')} \", \"red bold\"),\n        (f\"{failed} Failed\", \"bold\"),\n    )\n\n    if errors &gt; 0:\n        summary = Text.assemble(\n            summary,\n            (\"    \u26a0 \", \"yellow bold\"),\n            (f\"{errors} Errors\", \"bold\"),\n        )\n\n    if debug:\n        summary = Text.assemble(\n            summary,\n            (\"    \ud83d\udd52 \", \"dim\"),\n            (f\"{duration_ms:.1f}ms\", \"dim\"),\n        )\n\n    console.print(summary)\n</code></pre>"},{"location":"api/#doctor","title":"Doctor","text":""},{"location":"api/#azure_functions_doctor.doctor.Doctor","title":"<code>Doctor(path='.')</code>","text":"<p>Diagnostic runner for Azure Functions apps. Loads checks from rules.json and executes them against a target project path.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def __init__(self, path: str = \".\") -&gt; None:\n    self.project_path: Path = Path(path).resolve()\n</code></pre>"},{"location":"api/#handlers","title":"Handlers","text":""},{"location":"api/#azure_functions_doctor.handlers.generic_handler","title":"<code>generic_handler(rule, path)</code>","text":"<p>Execute a diagnostic rule based on its type and condition.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Rule</code> <p>The diagnostic rule to execute.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the status and detail of the check.</p> Source code in <code>src/azure_functions_doctor/handlers.py</code> <pre><code>def generic_handler(rule: Rule, path: Path) -&gt; dict[str, str]:\n    \"\"\"\n    Execute a diagnostic rule based on its type and condition.\n\n    Args:\n        rule: The diagnostic rule to execute.\n\n    Returns:\n        A dictionary with the status and detail of the check.\n    \"\"\"\n    check_type = rule.get(\"type\")\n    condition = rule.get(\"condition\", {})\n\n    target = condition.get(\"target\")\n    operator = condition.get(\"operator\")\n    value = condition.get(\"value\")\n\n    # Compare current Python version with expected version\n    if check_type == \"compare_version\":\n        if not (target and operator and value):\n            return _create_result(\"fail\", \"Missing condition fields for compare_version\")\n\n        if target == \"python\":\n            current_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n            current = parse_version(current_version)\n            expected = parse_version(str(value))\n            passed = {\n                \"&gt;=\": current &gt;= expected,\n                \"&lt;=\": current &lt;= expected,\n                \"==\": current == expected,\n                \"&gt;\": current &gt; expected,\n                \"&lt;\": current &lt; expected,\n            }.get(operator, False)\n            return _create_result(\n                \"pass\" if passed else \"fail\",\n                f\"Python version is {current_version}, expected {operator}{value}\",\n            )\n\n        return _create_result(\"fail\", f\"Unknown target for version comparison: {target}\")\n\n    # Check if an environment variable is set\n    if check_type == \"env_var_exists\":\n        if not target:\n            return _create_result(\"fail\", \"Missing environment variable name\")\n\n        exists = os.getenv(target) is not None\n        return _create_result(\n            \"pass\" if exists else \"fail\",\n            f\"{target} is {'set' if exists else 'not set'}\",\n        )\n\n    # Check if a path exists (including sys.executable)\n    if check_type == \"path_exists\":\n        if not target:\n            return _create_result(\"fail\", \"Missing target path\")\n\n        resolved_path = sys.executable if target == \"sys.executable\" else os.path.join(path, target)\n        exists = os.path.exists(resolved_path)\n\n        if exists:\n            return _create_result(\"pass\", f\"{resolved_path} exists\")\n\n        if not rule.get(\"required\", True):\n            return _create_result(\"pass\", f\"{resolved_path} is missing (optional)\")\n\n        return _create_result(\"fail\", f\"{resolved_path} is missing\")\n\n    # Check if a specific file exists\n    if check_type == \"file_exists\":\n        if not target:\n            return _create_result(\"fail\", \"Missing file path\")\n\n        file_path = os.path.join(path, target)\n        exists = os.path.isfile(file_path)\n\n        if exists:\n            return _create_result(\"pass\", f\"{file_path} exists\")\n\n        if not rule.get(\"required\", True):\n            return _create_result(\"pass\", f\"{file_path} not found (optional for local development)\")\n\n        return _create_result(\"fail\", f\"{file_path} not found\")\n\n    # Check if a Python package is importable\n    if check_type == \"package_installed\":\n        if not target:\n            return _create_result(\"fail\", \"Missing package name\")\n\n        import_path_str: str = str(target)\n\n        try:\n            __import__(import_path_str)\n            return _create_result(\"pass\", f\"Module '{import_path_str}' is installed\")\n        except ImportError as exc:\n            return _create_result(\"fail\", f\"Module '{import_path_str}' is not installed: {exc}\")\n        except Exception as exc:\n            return _handle_exception(f\"importing module '{import_path_str}'\", exc)\n\n    # Check if a keyword exists in any .py source files\n    if check_type == \"source_code_contains\":\n        keyword = condition.get(\"keyword\")\n        if not isinstance(keyword, str):\n            return _create_result(\"fail\", \"Missing or invalid 'keyword' in condition\")\n\n        found = False\n\n        for py_file in path.rglob(\"*.py\"):\n            try:\n                content = py_file.read_text(encoding=\"utf-8\")\n                if keyword in content:\n                    found = True\n                    break\n            except Exception as exc:\n                logger.warning(f\"Failed to read file {py_file}: {exc}\")\n                continue\n\n        return _create_result(\n            \"pass\" if found else \"fail\",\n            f\"Keyword '{keyword}' {'found' if found else 'not found'} in source code\",\n        )\n\n    # Unknown check type fallback\n    return _create_result(\"fail\", f\"Unknown check type: {check_type}\")\n</code></pre>"},{"location":"api/#check-logic","title":"Check Logic","text":""},{"location":"api/#azure_functions_doctor.check.run_check","title":"<code>run_check(rule, base_path)</code>","text":"<p>Wrap the generic_handler to cast a raw rule into a typed Rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>dict[str, Any]</code> <p>Dictionary parsed from rules.json</p> required <code>base_path</code> <code>Path</code> <p>Path to Azure Functions app</p> required <p>Returns:</p> Type Description <code>CheckResult</code> <p>Structured result with status, label, value, and optional hint.</p> Source code in <code>src/azure_functions_doctor/check.py</code> <pre><code>def run_check(rule: dict[str, Any], base_path: Path) -&gt; CheckResult:\n    \"\"\"\n    Wrap the generic_handler to cast a raw rule into a typed Rule.\n\n    Args:\n        rule: Dictionary parsed from rules.json\n        base_path: Path to Azure Functions app\n\n    Returns:\n        Structured result with status, label, value, and optional hint.\n    \"\"\"\n    typed_rule = cast(Rule, rule)\n    result = generic_handler(typed_rule, base_path)\n\n    output: CheckResult = {\n        \"status\": result[\"status\"],\n        \"label\": typed_rule.get(\"label\", typed_rule[\"id\"]),\n        \"value\": result[\"detail\"],\n    }\n\n    if \"hint\" in typed_rule:\n        output[\"hint\"] = typed_rule[\"hint\"]\n\n    return output\n</code></pre>"},{"location":"api/#target-resolver","title":"Target Resolver","text":""},{"location":"api/#azure_functions_doctor.target_resolver.resolve_target_value","title":"<code>resolve_target_value(target)</code>","text":"<p>Resolve the current value of a target used in version comparison or diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representing the resolved version or value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target is not recognized.</p> Source code in <code>src/azure_functions_doctor/target_resolver.py</code> <pre><code>def resolve_target_value(target: str) -&gt; str:\n    \"\"\"\n    Resolve the current value of a target used in version comparison or diagnostics.\n\n    Args:\n        target: The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".\n\n    Returns:\n        A string representing the resolved version or value.\n\n    Raises:\n        ValueError: If the target is not recognized.\n    \"\"\"\n    if target == \"python\":\n        return sys.version.split()[0]\n    if target == \"func_core_tools\":\n        try:\n            output = subprocess.check_output([\"func\", \"--version\"], text=True)\n            return output.strip()\n        except Exception as exc:\n            logger.warning(f\"Failed to get func core tools version: {exc}\")\n            return \"0.0.0\"  # Return a fallback version if resolution fails\n    raise ValueError(f\"Unknown target: {target}\")\n</code></pre>"},{"location":"api/#utility","title":"Utility","text":""},{"location":"api/#azure_functions_doctor.utils.format_detail","title":"<code>format_detail(status, value)</code>","text":"<p>Return a colored Text element based on status and value.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <code>value</code> <code>str</code> <p>Text to display, typically a description.</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object styled with status color.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_detail(status: str, value: str) -&gt; Text:\n    \"\"\"\n    Return a colored Text element based on status and value.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n        value: Text to display, typically a description.\n\n    Returns:\n        A Rich Text object styled with status color.\n    \"\"\"\n    color = DETAIL_COLOR_MAP.get(status, \"white\")\n    return Text(value, style=color)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_result","title":"<code>format_result(status)</code>","text":"<p>Return a styled icon Text element based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object with icon and style for headers.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_result(status: str) -&gt; Text:\n    \"\"\"\n    Return a styled icon Text element based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A Rich Text object with icon and style for headers.\n    \"\"\"\n    style = STATUS_STYLES.get(status, Style(color=\"white\"))\n    icon = format_status_icon(status)\n    return Text(icon, style=style)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_status_icon","title":"<code>format_status_icon(status)</code>","text":"<p>Return a simple icon character based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string icon such as \u2714, \u2716, or \u26a0.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_status_icon(status: str) -&gt; str:\n    \"\"\"\n    Return a simple icon character based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A string icon such as \u2714, \u2716, or \u26a0.\n    \"\"\"\n    return STATUS_ICONS.get(status, \"?\")\n</code></pre>"},{"location":"development/","title":"Development Guide (Hatch-based)","text":"<p>This guide covers how to set up a local development environment, run tests, and manage code quality for Azure Functions Doctor, using Hatch and a Makefile for workflow automation.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9+ installed on your system</li> <li>Git for version control</li> <li>Hatch as the build and environment manager (installed via <code>pip install hatch</code>)</li> <li>Make (for running the provided Makefile targets)</li> <li>(Optional) uv for fast dependency installation (<code>pip install uv</code>)</li> </ul>"},{"location":"development/#project-structure-overview","title":"Project Structure Overview","text":"<pre><code>azure-functions-doctor-for-python/\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 hatch.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 azure_functions_doctor/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 cli.py\n\u2502       \u251c\u2500\u2500 doctor.py\n\u2502       \u251c\u2500\u2500 handlers.py\n\u2502       \u251c\u2500\u2500 utils.py\n\u2502       \u251c\u2500\u2500 assets/\n\u2502       \u2502   \u2514\u2500\u2500 rules.json\n\u2502       \u2514\u2500\u2500 checks/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_cli.py\n\u2502   \u251c\u2500\u2500 test_handler.py\n\u2502   \u2514\u2500\u2500 test_*.py\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 usage.md\n\u2502   \u251c\u2500\u2500 rules.md\n\u2502   \u251c\u2500\u2500 diagnostics.md\n\u2502   \u2514\u2500\u2500 development.md\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 basic-hello/\n\u2502       \u2514\u2500\u2500 diagnose-output.md\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>Makefile</code>: Defines common commands for creating the environment, running tests, linting, formatting, and publishing.</li> <li><code>pyproject.toml</code> and <code>hatch.toml</code>: Configuration for Hatch environments and project metadata.</li> <li><code>src/azure_functions_doctor/</code>: Core application code, including CLI entrypoint, diagnostic logic, and rule assets.</li> <li><code>tests/</code>: Unit and integration tests for the project.</li> <li><code>docs/</code>: Documentation files used by MkDocs (if enabled) or GitHub pages.</li> <li><code>examples/</code>: Contains sample Azure Functions projects and expected outputs.</li> </ul>"},{"location":"development/#initial-setup","title":"Initial Setup","text":"<ol> <li> <p>Clone the repository:     <code>bash     git clone https://github.com/yeongseon/azure-functions-doctor-for-python.git     cd azure-functions-doctor-for-python</code></p> </li> <li> <p>Create and activate a virtual environment using the Makefile:     <code>bash     make venv     source .venv/bin/activate      # On Windows (PowerShell): .venv\\Scripts\\Activate.ps1</code></p> </li> <li> <p>Install project dependencies via Hatch (or using <code>uv</code> if preferred):     <code>bash     make install     # or, if using uv: uv install</code></p> </li> <li> <p>Install pre-commit hooks for code formatting and linting:     <code>bash     make precommit-install</code></p> </li> </ol> <p>Note: The Makefile ensures Hatch commands run inside the appropriate environment. If you bypass Makefile, you can manually do: <code>bash hatch env create default hatch run pip install -r requirements-dev.txt hatch run pre-commit install</code></p>"},{"location":"development/#running-tests-and-quality-checks","title":"Running Tests and Quality Checks","text":""},{"location":"development/#1-format-code","title":"1. Format Code","text":"<p>Use Black and Ruff via Makefile to enforce consistent styling:</p> <pre><code>make format\n</code></pre>"},{"location":"development/#2-lint-code","title":"2. Lint Code","text":"<p>Run Ruff and Mypy for linting and type checks:</p> <pre><code>make lint\n</code></pre>"},{"location":"development/#3-type-checking","title":"3. Type Checking","text":"<p>Perform static type analysis with Mypy:</p> <pre><code>make typecheck\n</code></pre>"},{"location":"development/#4-run-unit-tests","title":"4. Run Unit Tests","text":"<p>Execute all tests using pytest:</p> <pre><code>make test\n</code></pre>"},{"location":"development/#5-combined-quality-checks","title":"5. Combined Quality Checks","text":"<p>Run formatting, linting, type checking, and tests in one command:</p> <pre><code>make check\n</code></pre>"},{"location":"development/#6-generate-coverage-report","title":"6. Generate Coverage Report","text":"<p>Produce a coverage report (HTML + XML):</p> <pre><code>make cov\n</code></pre> <ul> <li>Opens <code>htmlcov/index.html</code> for browser viewing</li> <li>Generates <code>coverage.xml</code> for CI integrations (e.g., Codecov)</li> </ul>"},{"location":"development/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a feature branch:     <code>bash     git checkout -b feature/your-description</code></p> </li> <li> <p>Implement changes in <code>src/azure_functions_doctor/</code> and/or update <code>rules.json</code> under <code>src/azure_functions_doctor/assets/</code>.</p> </li> <li> <p>Add new tests in the <code>tests/</code> directory to cover your changes.</p> </li> <li> <p>Run quality checks locally:     <code>bash     make check</code></p> </li> <li> <p>Commit changes with Conventional Commits format:     <code>git commit -m \"feat: add new check for custom config file\"</code></p> </li> <li> <p>Push and open a Pull Request to <code>main</code>.</p> </li> </ol>"},{"location":"development/#makefile-targets-reference","title":"Makefile Targets Reference","text":"Target Description <code>make venv</code> Create a Python virtual environment at <code>.venv/</code> <code>make install</code> Install runtime and dev dependencies via Hatch (<code>hatch install</code>) <code>make precommit-install</code> Install pre-commit hooks (Black, Ruff, etc.) <code>make format</code> Format code with Black and apply Ruff fixes <code>make lint</code> Run Ruff and Mypy checks <code>make typecheck</code> Perform static type checking with Mypy <code>make test</code> Run pytest <code>make check</code> Run formatting, linting, typechecking, and tests in sequence <code>make cov</code> Generate coverage report and open HTML index <code>make docs</code> Serve MkDocs locally (if MkDocs configured) <code>make release-patch</code> Bump patch version, update changelog <code>make release-minor</code> Bump minor version, update changelog <code>make release-major</code> Bump major version, update changelog <code>make publish</code> Publish package to PyPI (requires credentials in environment) <p>For detailed release workflow, refer to <code>release_process.md</code>.</p>"},{"location":"development/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please follow these steps:</p> <ol> <li>Fork the repository and create a new branch.</li> <li>Follow the Development Workflow above.</li> <li>Ensure tests pass and code quality checks succeed.</li> <li>Submit a Pull Request with a clear description of your changes.</li> </ol> <p>Thank you for helping improve Azure Functions Doctor!</p>"},{"location":"development/#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"diagnostics/","title":"Diagnostics","text":""},{"location":"diagnostics/#diagnostic-checks-updated-for-azure-functions-python-programming-model-v2","title":"\ud83d\ude7a Diagnostic Checks (Updated for Azure Functions Python Programming Model v2)","text":"<p>This document lists diagnostic checks for Azure Functions Doctor, based on Azure Functions Python Reference and Best Practices.</p> # Diagnostic Check Description Feasibility Status 1 Python version \u2265 3.9 Check if the runtime meets minimum requirements \u2705 Easy \u2705 Implemented 2 Virtual environment (.venv) active Ensure Python environment is isolated via virtualenv \u2705 Easy \u2705 Implemented 3 Azure Functions Core Tools installed Validate that <code>func</code> CLI is installed and accessible \u2705 Easy \u2705 Implemented 4 <code>host.json</code> exists Required runtime configuration file must be present \u2705 Easy \u2705 Implemented 5 <code>requirements.txt</code> exists Check for dependency management file \u2705 Easy \u2705 Implemented 6 <code>azure-functions</code> package installed Ensure required Azure Functions SDK is installed \u2705 Easy \u2705 Implemented 7 <code>azure-functions-python-library</code> installed Required for Programming Model v2 decorator syntax \u2705 Easy \u2705 Implemented 8 <code>local.settings.json</code> exists (optional) Useful for storing app settings locally Easy Planned 9 Detect use of decorators Confirm use of v2-style decorators like <code>@function_name</code> \u2705 Easy \u2705 Implemented 10 Function mode detection (v1 vs v2) Detect whether app uses function.json or decorators Medium Planned 11 Directory structure validation Warn if folder structure is non-standard or missing expected files \u2705 Easy \u2705 Implemented 12 Durable Functions config in <code>host.json</code> Check for presence of <code>durableTask</code> section Medium Planned 13 HTTP trigger validation Ensure <code>authLevel</code>, <code>methods</code>, <code>route</code> in binding are valid Medium Planned 14 Timer trigger CRON validation Validate correct CRON format Medium Planned 15 App Insights configuration Validate presence of instrumentation key or connection string Medium Planned 16 EntryPoint in <code>function.json</code> (v1 only) Check if entryPoint matches a real function (v1 only) \u2705 Easy \u274c Not needed 17 Function name and folder match (v1 only) Ensure folder/function naming aligns (v1 only) \u2705 Easy \u274c Not needed 18 ASGI/WSGI compatibility Check if app exposes ASGI/WSGI callable Medium Planned 19 Detect unused or invalid files Warn about <code>.pyc</code>, <code>__pycache__</code>, or legacy files \u2705 Low \ud83d\udd1d Possible 20 Detect long-running blocking patterns Detect <code>sleep()</code>, infinite loops, or sync IO blocking \u274c Hard \u274c Not feasible 21 Excessive logging Detect overuse of <code>print()</code> or <code>logging.debug()</code> \u274c Runtime \u274c Not feasible 22 Monolithic layout warning Detect if everything is in one large file \u274c Context \u274c Not feasible <p>Legend: \u2705 Easy = statically checkable \u2705 Medium = requires additional parsing/context \u274c = not feasible by static analysis Planned = scheduled for future implementation \ud83e\udded Possible = technically feasible but lower priority</p>"},{"location":"diagnostics/#key-changes","title":"\u2705 Key Changes","text":"<ul> <li>Removed <code>main.py</code> check (was v1 specific)</li> <li>Added decorator detection (v2 model confirmation)</li> <li>Excluded v1-only checks like <code>entryPoint</code>, <code>function.json</code> folder matching</li> <li>Included v2-only checks like <code>azure-functions-python-library</code></li> <li>Clarified feasibility and implementation status across all checks</li> </ul>"},{"location":"release_process/","title":"Release Process","text":"<p>This document outlines the steps to release a new version of Azure Functions Doctor to PyPI and update the changelog using the existing Makefile and Hatch-based workflows.</p>"},{"location":"release_process/#step-1-bump-version-and-generate-changelog","title":"\ud83e\uddfe Step 1: Bump Version and Generate Changelog","text":"<p>Use Makefile targets to bump the version and update the changelog:</p> <pre><code>make release-patch     # Patch release (e.g., v0.1.0 \u2192 v0.1.1)\nmake release-minor     # Minor release (e.g., v0.1.1 \u2192 v0.2.0)\nmake release-major     # Major release (e.g., v0.2.0 \u2192 v1.0.0)\n</code></pre> <p>Each command will: - Update the version in <code>src/azure_functions_doctor/__init__.py</code> - Generate or update <code>CHANGELOG.md</code> via <code>git-cliff</code> - Commit the version bump and changelog - Create a Git tag (e.g., <code>v0.2.0</code>) and push to <code>main</code></p> <p>Make sure your <code>main</code> branch is up-to-date before running these commands.</p>"},{"location":"release_process/#step-2-build-and-test-the-package","title":"Step 2: Build and Test the Package","text":"<pre><code>make build\n</code></pre> <p>To test the local build:</p> <pre><code>pip install dist/azure_functions_doctor-&lt;version&gt;-py3-none-any.whl\nfunc-doctor --version\n</code></pre>"},{"location":"release_process/#step-3-publish-to-pypi","title":"Step 3: Publish to PyPI","text":"<pre><code>make publish-pypi\n</code></pre> <ul> <li>Uses <code>hatch publish</code> under the hood</li> <li>Relies on <code>.pypirc</code> for authentication (<code>~/.pypirc</code> must contain PyPI token)</li> <li>No need for <code>twine</code></li> </ul>"},{"location":"release_process/#step-4-optional-publish-to-testpypi","title":"\ud83d\udd01 Step 4: (Optional) Publish to TestPyPI","text":"<pre><code>make publish-test\n</code></pre> <p>To install from TestPyPI:</p> <pre><code>pip install --index-url https://test.pypi.org/simple/ azure-functions-doctor\n</code></pre>"},{"location":"release_process/#summary-of-makefile-commands","title":"\u2705 Summary of Makefile Commands","text":"Task Command Version bump + changelog <code>make release-patch</code> Build distributions <code>make build</code> Publish to PyPI <code>make publish-pypi</code> Publish to TestPyPI <code>make publish-test</code>"},{"location":"release_process/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CHANGELOG.md</li> <li>Development Guide</li> <li>Makefile Targets</li> <li>PyPI Publishing with Hatch</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#vision","title":"Vision","text":"<p>Transform Azure Functions Doctor from a basic environment validator into a comprehensive static analysis and CI/CD platform for Azure Functions development teams.</p> <p>Our goal is to become the essential quality assurance tool for Azure Functions projects, providing deep insights into code quality, security, performance, and best practices throughout the development lifecycle.</p>"},{"location":"roadmap/#current-state-v01x","title":"Current State (v0.1.x)","text":""},{"location":"roadmap/#what-we-have-today","title":"What We Have Today","text":"<ul> <li>\u2705 Basic environment validation (Python version, virtual environment, packages)</li> <li>\u2705 Configuration file validation (<code>host.json</code>, <code>local.settings.json</code>, project structure)</li> <li>\u2705 Extensible rule-based diagnostic system via <code>rules.json</code></li> <li>\u2705 CLI interface with colorized output and JSON format support</li> <li>\u2705 Comprehensive documentation and open source contribution guidelines</li> </ul>"},{"location":"roadmap/#current-limitations","title":"Current Limitations","text":"<ul> <li>Limited to basic setup validation</li> <li>Static file checks only, no code analysis</li> <li>Manual execution required</li> <li>No CI/CD integration</li> <li>No security or performance insights</li> </ul>"},{"location":"roadmap/#phase-1-static-analysis-platform-v02-03","title":"Phase 1: Static Analysis Platform (v0.2-0.3)","text":"<p>Timeline: 3-6 months</p>"},{"location":"roadmap/#goals","title":"Goals","text":"<p>Evolve from basic validation to comprehensive Azure Functions code analysis.</p>"},{"location":"roadmap/#new-capabilities","title":"New Capabilities","text":""},{"location":"roadmap/#security-analysis","title":"Security Analysis","text":"<ul> <li>Secrets detection: Scan for hardcoded API keys, connection strings, passwords</li> <li>Authentication patterns: Validate proper use of Azure AD, managed identity</li> <li>Input validation: Detect missing input sanitization in HTTP triggers</li> <li>HTTPS enforcement: Check for insecure HTTP configurations</li> <li>CORS configuration: Validate CORS policies for security</li> </ul>"},{"location":"roadmap/#performance-analysis","title":"Performance Analysis","text":"<ul> <li>Cold start optimization: Detect patterns that increase cold start times</li> <li>Memory usage patterns: Identify potential memory leaks or excessive usage</li> <li>Async/await best practices: Ensure proper asynchronous programming</li> <li>Database connection pooling: Validate efficient database access patterns</li> <li>Dependency injection: Check for proper dependency management</li> </ul>"},{"location":"roadmap/#code-quality","title":"Code Quality","text":"<ul> <li>Complexity metrics: Measure cyclomatic complexity, code maintainability</li> <li>Azure Functions best practices: Validate idiomatic patterns</li> <li>Error handling: Ensure proper exception handling and logging</li> <li>Testing coverage: Integration with test frameworks and coverage tools</li> <li>Documentation quality: Check for proper docstrings and type hints</li> </ul>"},{"location":"roadmap/#advanced-rule-system","title":"Advanced Rule System","text":"<ul> <li>Custom rule definitions: Allow teams to define organization-specific rules</li> <li>Rule severity levels: Warning, error, critical classifications</li> <li>Rule categories: Security, performance, maintainability, style</li> <li>Configuration profiles: Different rule sets for different environments</li> <li>Rule exceptions: Ability to suppress specific rules for specific files/functions</li> </ul>"},{"location":"roadmap/#technical-implementation","title":"Technical Implementation","text":"<ul> <li>AST parsing for deep code analysis</li> <li>Integration with Python security tools (bandit, safety)</li> <li>Performance pattern detection algorithms</li> <li>Extensible plugin architecture for custom analyzers</li> </ul>"},{"location":"roadmap/#phase-2-cicd-integration-platform-v04-05","title":"Phase 2: CI/CD Integration Platform (v0.4-0.5)","text":"<p>Timeline: 6-9 months</p>"},{"location":"roadmap/#goals_1","title":"Goals","text":"<p>Seamlessly integrate into development workflows and automate quality gates.</p>"},{"location":"roadmap/#cicd-integrations","title":"CI/CD Integrations","text":""},{"location":"roadmap/#github-actions","title":"GitHub Actions","text":"<ul> <li>Pre-built action: <code>yeongseon/azure-functions-doctor-action</code></li> <li>PR checks: Automatic analysis on pull requests with inline comments</li> <li>Quality gates: Configurable pass/fail thresholds</li> <li>Trend tracking: Historical analysis across commits</li> <li>Integration with GitHub Security tab: Security findings visible in GitHub UI</li> </ul>"},{"location":"roadmap/#azure-devops","title":"Azure DevOps","text":"<ul> <li>Azure DevOps extension: Native integration with Azure Pipelines</li> <li>Build validation: Automatic analysis during build process</li> <li>Release gates: Quality checks before deployment to staging/production</li> <li>Work item integration: Link findings to Azure DevOps work items</li> <li>Dashboard widgets: Visual quality metrics in Azure DevOps dashboards</li> </ul>"},{"location":"roadmap/#jenkins-other-platforms","title":"Jenkins &amp; Other Platforms","text":"<ul> <li>Jenkins plugin: Native Jenkins integration</li> <li>Docker images: Containerized execution for any CI platform</li> <li>CLI integration: Easy integration with any build system</li> <li>Webhook support: Real-time notifications to external systems</li> </ul>"},{"location":"roadmap/#reporting-analytics","title":"Reporting &amp; Analytics","text":"<ul> <li>Quality dashboards: Web-based dashboards showing trends and metrics</li> <li>Team analytics: Code quality insights across teams and projects</li> <li>Historical tracking: Quality improvements/degradations over time</li> <li>Export capabilities: Integration with external reporting tools</li> <li>Notifications: Slack, Teams, email notifications for quality issues</li> </ul>"},{"location":"roadmap/#policy-enforcement","title":"Policy Enforcement","text":"<ul> <li>Organizational policies: Centralized rule management for enterprises</li> <li>Compliance reporting: SOX, GDPR, industry-specific compliance checks</li> <li>Quality metrics: Configurable quality score calculations</li> <li>Exemption management: Approval workflows for rule exceptions</li> <li>Audit trails: Complete history of quality decisions and changes</li> </ul>"},{"location":"roadmap/#phase-3-developer-platform-v10","title":"Phase 3: Developer Platform (v1.0+)","text":"<p>Timeline: 12-18 months</p>"},{"location":"roadmap/#goals_2","title":"Goals","text":"<p>Become an integral part of the developer experience with real-time feedback and collaboration features.</p>"},{"location":"roadmap/#ide-integration","title":"IDE Integration","text":""},{"location":"roadmap/#vs-code-extension","title":"VS Code Extension","text":"<ul> <li>Real-time analysis: Live feedback as developers write code</li> <li>Inline suggestions: Fix recommendations directly in the editor</li> <li>Rule explanations: Contextual help for understanding quality issues</li> <li>Quick fixes: Automated code fixes for common issues</li> <li>Workspace integration: Project-specific configuration and rules</li> </ul>"},{"location":"roadmap/#multi-ide-support","title":"Multi-IDE Support","text":"<ul> <li>JetBrains IDEs: PyCharm, IntelliJ IDEA integration</li> <li>Vim/Neovim: Language server protocol support</li> <li>Sublime Text: Package for Sublime Text users</li> <li>Emacs: Integration with Emacs ecosystem</li> </ul>"},{"location":"roadmap/#developer-experience-features","title":"Developer Experience Features","text":""},{"location":"roadmap/#intelligent-suggestions","title":"Intelligent Suggestions","text":"<ul> <li>AI-powered recommendations: Machine learning-based improvement suggestions</li> <li>Context-aware fixes: Understanding of Azure Functions patterns</li> <li>Learning from feedback: Improve suggestions based on user acceptance</li> <li>Code generation: Generate boilerplate code following best practices</li> </ul>"},{"location":"roadmap/#collaboration-tools","title":"Collaboration Tools","text":"<ul> <li>Team standards: Shared rule configurations across teams</li> <li>Knowledge sharing: Wiki-style documentation for internal best practices</li> <li>Peer review integration: Enhanced code review workflows</li> <li>Mentoring features: Guidance for junior developers</li> </ul>"},{"location":"roadmap/#platform-features","title":"Platform Features","text":""},{"location":"roadmap/#rule-marketplace","title":"Rule Marketplace","text":"<ul> <li>Community rules: Share and discover rules created by the community</li> <li>Industry standards: Rules for specific industries (healthcare, finance, etc.)</li> <li>Organizational templates: Starter rule sets for common scenarios</li> <li>Versioning: Semantic versioning for rule sets</li> <li>Rating system: Community feedback on rule quality</li> </ul>"},{"location":"roadmap/#advanced-analytics","title":"Advanced Analytics","text":"<ul> <li>Predictive insights: Identify potential issues before they occur</li> <li>Technical debt tracking: Quantify and track technical debt</li> <li>Developer productivity: Metrics on how quality tools impact productivity</li> <li>Cost analysis: Understanding the business impact of quality issues</li> </ul>"},{"location":"roadmap/#technology-strategy","title":"Technology Strategy","text":""},{"location":"roadmap/#core-architecture-evolution","title":"Core Architecture Evolution","text":"<ul> <li>Microservices architecture: Scalable, maintainable service design</li> <li>Cloud-native: Azure Functions for processing, Cosmos DB for storage</li> <li>API-first: REST APIs for all functionality to enable integrations</li> <li>Event-driven: Asynchronous processing for large codebases</li> </ul>"},{"location":"roadmap/#performance-scalability","title":"Performance &amp; Scalability","text":"<ul> <li>Parallel processing: Analyze multiple files/projects simultaneously</li> <li>Caching strategies: Intelligent caching for faster repeated analysis</li> <li>Incremental analysis: Only analyze changed code</li> <li>Distributed execution: Scale analysis across multiple workers</li> </ul>"},{"location":"roadmap/#security-compliance","title":"Security &amp; Compliance","text":"<ul> <li>Zero-trust architecture: Security by design in all components</li> <li>Data privacy: GDPR compliance for user data and code analysis</li> <li>Enterprise security: SSO integration, audit logging, role-based access</li> <li>On-premises deployment: Support for organizations with strict data policies</li> </ul>"},{"location":"roadmap/#community-ecosystem","title":"Community &amp; Ecosystem","text":""},{"location":"roadmap/#open-source-strategy","title":"Open Source Strategy","text":"<ul> <li>Transparent roadmap: Public roadmap with community input</li> <li>Contributor onboarding: Comprehensive guides for new contributors</li> <li>Special Interest Groups: Focus areas (security, performance, etc.)</li> <li>Regular releases: Predictable release cadence with clear communication</li> </ul>"},{"location":"roadmap/#partnership-opportunities","title":"Partnership Opportunities","text":"<ul> <li>Microsoft partnership: Integration with Azure ecosystem</li> <li>Tool integrations: Native support in popular development tools</li> <li>Training providers: Integration with Azure Functions training materials</li> <li>Consulting partnerships: Work with Azure consulting partners</li> </ul>"},{"location":"roadmap/#success-metrics","title":"Success Metrics","text":"<ul> <li>Adoption: Number of projects using Azure Functions Doctor</li> <li>Community: Contributors, GitHub stars, community discussions</li> <li>Quality impact: Measurable improvement in code quality for users</li> <li>Business value: Time saved, bugs prevented, security issues avoided</li> </ul>"},{"location":"roadmap/#getting-involved","title":"Getting Involved","text":""},{"location":"roadmap/#for-contributors","title":"For Contributors","text":"<ul> <li>Early phases: Focus on core static analysis capabilities</li> <li>Rule development: Create domain-specific rules for your industry</li> <li>Integration development: Build connectors for your preferred tools</li> <li>Documentation: Help improve guides and best practices</li> </ul>"},{"location":"roadmap/#for-organizations","title":"For Organizations","text":"<ul> <li>Early adopter program: Get early access to enterprise features</li> <li>Feedback partnership: Shape the roadmap based on real-world needs</li> <li>Case studies: Share success stories with the community</li> <li>Sponsorship: Support development of specific features</li> </ul>"},{"location":"roadmap/#for-users","title":"For Users","text":"<ul> <li>Feature requests: Help prioritize development based on real needs</li> <li>Beta testing: Early access to new capabilities</li> <li>Community building: Share experiences and best practices</li> <li>Evangelism: Help spread awareness in the Azure Functions community</li> </ul>"},{"location":"roadmap/#risk-mitigation","title":"Risk Mitigation","text":""},{"location":"roadmap/#technical-risks","title":"Technical Risks","text":"<ul> <li>Complexity management: Keep architecture simple and maintainable</li> <li>Performance degradation: Continuous performance testing and optimization</li> <li>Azure API changes: Robust abstraction layers and version management</li> </ul>"},{"location":"roadmap/#market-risks","title":"Market Risks","text":"<ul> <li>Microsoft competition: Focus on community-driven features and flexibility</li> <li>Adoption challenges: Invest heavily in developer experience and documentation</li> <li>Resource constraints: Prioritize features with highest impact</li> </ul>"},{"location":"roadmap/#sustainability","title":"Sustainability","text":"<ul> <li>Funding model: Consider enterprise licensing for advanced features</li> <li>Community health: Ensure sustainable contributor pipeline</li> <li>Technical debt: Regular refactoring and architecture reviews</li> </ul> <p>This roadmap represents our commitment to building the premier quality assurance platform for Azure Functions development. We welcome feedback, contributions, and partnerships to make this vision a reality.</p> <p>Last updated: August 2024 Next review: November 2024</p>"},{"location":"rules/","title":"\ud83d\udcd8 <code>rules.json</code> Documentation","text":"<p>The <code>rules.json</code> file defines diagnostic checks declaratively for Azure Functions Doctor. Each rule specifies what to validate, how to validate it, and what to show when the check passes or fails \u2014 without modifying the core Python code.</p> <p>This makes the tool extensible and customizable.</p>"},{"location":"rules/#location","title":"\ud83d\udcc1 Location","text":"<p>The file is located under the assets/ directory:</p> <pre><code>src/\n\u2514\u2500\u2500 azure_functions_doctor/\n    \u2514\u2500\u2500 assets/\n        \u2514\u2500\u2500 rules.json  \ud83d\udc48\n</code></pre>"},{"location":"rules/#structure-of-a-rule","title":"\u2310 Structure of a Rule","text":"<p>Each rule is a JSON object with the following fields:</p> <pre><code>{\n  \"id\": \"check_python_version\",\n  \"section\": \"python_env\",\n  \"label\": \"Python version\",\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\",\n  \"hint\": \"Install Python 3.9 or higher.\"\n}\n</code></pre>"},{"location":"rules/#fields-explained","title":"\ud83d\udd11 Fields Explained","text":"Field Type Description <code>id</code> string Unique identifier for the rule <code>section</code> string Logical group (e.g. <code>python_env</code>, <code>config_files</code>) <code>label</code> string Human-readable label for the check <code>type</code> string Rule type (see below) <code>target</code> string Subject to evaluate (e.g. Python version, file path) <code>operator</code> string Comparison operator (e.g. <code>==</code>, <code>!=</code>, <code>&gt;=</code>) <code>value</code> any Expected value to compare <code>hint</code> string Suggestion if the rule fails"},{"location":"rules/#supported-rule-types","title":"Supported Rule Types","text":""},{"location":"rules/#1-compare_version","title":"1. <code>compare_version</code>","text":"<p>Compare semantic versions.</p> <pre><code>{\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\"\n}\n</code></pre> <ul> <li>Valid <code>target</code>: <code>\"python\"</code>, <code>\"azure-functions-core-tools\"</code></li> </ul>"},{"location":"rules/#2-file_exists","title":"2. <code>file_exists</code>","text":"<p>Check whether a file exists.</p> <pre><code>{\n  \"type\": \"file_exists\",\n  \"target\": \"host.json\"\n}\n</code></pre>"},{"location":"rules/#3-file_contains","title":"3. <code>file_contains</code>","text":"<p>Check whether a file contains a specific string or key path.</p> <pre><code>{\n  \"type\": \"file_contains\",\n  \"target\": \"host.json\",\n  \"key_path\": [\"version\"],\n  \"value\": \"2.0\"\n}\n</code></pre>"},{"location":"rules/#4-custom","title":"4. <code>custom</code>","text":"<p>You may register custom handlers in code using the <code>@handler.register(\"your_type\")</code> decorator. Add a <code>\"type\": \"custom\"</code> field and let your handler interpret additional keys under <code>condition</code>.</p>"},{"location":"rules/#grouping-by-section","title":"\ud83d\udcc1 Grouping by <code>section</code>","text":"<p>Sections allow grouping related checks together for better readability in the CLI output:</p> <p>Example:</p> <pre><code>{\n  \"section\": \"python_env\",\n  \"label\": \"Python Version\",\n  ...\n}\n</code></pre> <p>Predefined sections might include:</p> <ul> <li><code>python_env</code></li> <li><code>core_tools</code></li> <li><code>config_files</code></li> <li><code>dependencies</code></li> <li><code>network</code></li> </ul> <p>You can create your own section names if desired.</p>"},{"location":"rules/#extending-the-rules","title":"\ud83e\uddf9 Extending the Rules","text":"<p>To add a new rule:</p> <ol> <li>Open <code>src/azure_functions_doctor/assets/rules.json</code></li> <li>Append your rule object to the array</li> <li>Save and rerun <code>func-doctor</code></li> </ol> <p>Example:</p> <pre><code>{\n  \"id\": \"check_requirements_txt_exists\",\n  \"section\": \"dependencies\",\n  \"label\": \"requirements.txt exists\",\n  \"type\": \"file_exists\",\n  \"target\": \"requirements.txt\",\n  \"hint\": \"Create a requirements.txt file to declare Python dependencies.\"\n}\n</code></pre>"},{"location":"rules/#tips","title":"Tips","text":"<ul> <li>Use <code>hint</code> to provide helpful, actionable suggestions.</li> <li>Use consistent <code>section</code> names for better CLI grouping.</li> <li>If you're writing custom rule types, register them in <code>handlers.py</code>.</li> </ul>"},{"location":"rules/#testing-your-changes","title":"\ud83e\udd6a Testing Your Changes","text":"<p>After editing <code>rules.json</code>, you can run:</p> <pre><code>func-doctor diagnose --verbose\n</code></pre> <p>To see grouped results and hints.</p>"},{"location":"rules/#example-rulesjson-simplified","title":"\ud83d\udcdf Example <code>rules.json</code> (simplified)","text":"<pre><code>[\n  {\n    \"id\": \"check_python_version\",\n    \"section\": \"python_env\",\n    \"label\": \"Python version\",\n    \"type\": \"compare_version\",\n    \"target\": \"python\",\n    \"operator\": \"&gt;=\",\n    \"value\": \"3.9\",\n    \"hint\": \"Install Python 3.9 or higher.\"\n  },\n  {\n    \"id\": \"check_host_json_exists\",\n    \"section\": \"config_files\",\n    \"label\": \"host.json exists\",\n    \"type\": \"file_exists\",\n    \"target\": \"host.json\"\n  }\n]\n</code></pre>"},{"location":"rules/#contribute-new-rules","title":"\ud83d\udcec Contribute New Rules","text":"<p>Want to improve the default rules? Feel free to open a PR or discussion on \ud83d\udc49 GitHub Repository</p>"},{"location":"usage/","title":"\ud83d\udda5\ufe0f CLI Usage: <code>func-doctor</code>","text":"<p>The Azure Functions Doctor CLI helps validate your local Python-based Azure Functions project for common issues using an extensible rules system.</p>"},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<pre><code>func-doctor diagnose\n</code></pre> <p>Run diagnostics in the current or specified folder.</p>"},{"location":"usage/#options","title":"Options","text":"Option Description <code>--path</code> Target directory (default: current folder) <code>--format json</code> Output in machine-readable JSON <code>--verbose</code> Show detailed diagnostics and hints <code>--help</code> Show usage for the CLI or subcommand <p>Example:</p> <pre><code>func-doctor diagnose --path ./my-func-app --format json --verbose\n</code></pre>"},{"location":"usage/#what-it-checks","title":"\u2705 What It Checks","text":"Category Description Python Environment Python version \u2265 3.9, virtualenv activated, executable exists Dependencies <code>requirements.txt</code> present, <code>azure-functions</code> installed Project Files <code>host.json</code>, <code>local.settings.json</code>, and <code>main.py</code> exist"},{"location":"usage/#example-output","title":"Example Output","text":"<pre><code>\ud83e\ude7a Azure Functions Doctor for Python v0.1.0\n\ud83d\udcc1 Path: /root/Github/azure-functions-doctor/examples/basic-hello\n\n\u2716 Python Env\n  \u2022 Python version: Python version is 3.12.3, expected &gt;=3.9\n  \u2022 Virtual environment: VIRTUAL_ENV is set\n  \u2022 Python executable: .../bin/python exists\n  \u2022 requirements.txt: exists\n  \u2022 azure-functions package: Package 'azure_functions' is not installed\n\n\u2716 Project Structure\n  \u2022 host.json: exists\n  \u2022 local.settings.json: is missing\n  \u2022 main.py: is missing\n\nSummary\n\u2714 0 Passed    \u2716 2 Failed\n</code></pre>"},{"location":"usage/#help","title":"\ud83c\udd98 Help","text":"<pre><code>func-doctor --help\nfunc-doctor diagnose --help\n</code></pre> <p>For more examples, see the example project.</p>"}]}