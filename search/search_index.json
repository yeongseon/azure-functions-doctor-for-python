{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83e\ude7a Azure Functions Doctor","text":"<p>Welcome to Azure Functions Doctor \u2014 a powerful diagnostic CLI tool built with Python to help you validate and troubleshoot your local Azure Functions environment.</p>"},{"location":"#what-is-it","title":"\u26a1 What Is It?","text":"<p>Azure Functions Doctor analyzes your project folder and environment to detect:</p> <ul> <li>Missing configuration files (e.g., <code>host.json</code>, <code>requirements.txt</code>)</li> <li>Unsupported Python versions</li> <li>Missing dependencies (e.g., <code>azure-functions</code>)</li> <li>Broken or misnamed function folders</li> <li>Other common issues that break Azure Functions locally or in CI/CD</li> </ul> <p>It provides clear emoji-based output, rule-based extensibility, and optional JSON formatting.</p>"},{"location":"#when-should-you-use-this","title":"\ud83d\ude80 When Should You Use This?","text":"Scenario Usefulness \ud83e\uddea Developing locally Quickly catch broken setup before you run <code>func start</code> \ud83d\udea2 Before deployment Prevent silent 500 errors caused by bad config \ud83d\udd01 In CI pipeline Automate validation across repos and branches \ud83d\udee0 Debugging errors Eliminate basic mistakes before diving into logs"},{"location":"#quick-start","title":"\ud83e\uddf0 Quick Start","text":"<pre><code>pip install azure-functions-doctor\nfunc-doctor diagnose\n</code></pre> <p>View Usage Guide \u2192 See Example Project \u2192</p>"},{"location":"#documentation-overview","title":"\ud83d\udcd8 Documentation Overview","text":"Topic Description Usage Guide How to run and interpret results Rule System Understand and customize <code>rules.json</code> Diagnostics Reference Full list of built-in checks Developer Guide Contribute and extend the CLI Release Process Versioning and PyPI publishing"},{"location":"#need-help","title":"\ud83d\udcac Need Help?","text":"<p>Feel free to open an issue or check out our GitHub Discussions.</p>"},{"location":"#example-output","title":"\ud83e\uddea Example Output","text":""},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"api/","title":"\ud83e\udde0 API Reference","text":""},{"location":"api/#cli","title":"CLI","text":""},{"location":"api/#azure_functions_doctor.cli.diagnose","title":"<code>diagnose(path='.', verbose=False, format='table', output=None)</code>","text":"<p>Run diagnostics on an Azure Functions application.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Azure Functions app. Defaults to current directory.</p> <code>'.'</code> <code>verbose</code> <code>bool</code> <p>Show detailed hints for failed checks.</p> <code>False</code> <code>format</code> <code>Annotated[str, Option(help=\"Output format: 'table' or 'json'\")]</code> <p>Output format: 'table' or 'json'.</p> <code>'table'</code> <code>output</code> <code>Annotated[Optional[Path], Option(help='Optional path to save JSON result')]</code> <p>Optional file path to save JSON result.</p> <code>None</code> Source code in <code>src/azure_functions_doctor/cli.py</code> <pre><code>@cli.command()\ndef diagnose(\n    path: str = \".\",\n    verbose: bool = False,\n    format: Annotated[str, typer.Option(help=\"Output format: 'table' or 'json'\")] = \"table\",\n    output: Annotated[Optional[Path], typer.Option(help=\"Optional path to save JSON result\")] = None,\n) -&gt; None:\n    \"\"\"\n    Run diagnostics on an Azure Functions application.\n\n    Args:\n        path: Path to the Azure Functions app. Defaults to current directory.\n        verbose: Show detailed hints for failed checks.\n        format: Output format: 'table' or 'json'.\n        output: Optional file path to save JSON result.\n    \"\"\"\n    doctor = Doctor(path)\n    results = doctor.run_all_checks()\n\n    passed = failed = 0\n\n    if format == \"json\":\n        import json\n\n        json_output = results\n\n        if output:\n            output.parent.mkdir(parents=True, exist_ok=True)\n            output.write_text(json.dumps(json_output, indent=2), encoding=\"utf-8\")\n            console.print(f\"[green]\u2713 JSON output saved to:[/green] {output}\")\n        else:\n            print(json.dumps(json_output, indent=2))\n        return\n\n    # Print header only for table format\n    console.print(f\"[bold blue]\ud83e\ude7a Azure Functions Doctor for Python v{__version__}[/bold blue]\")\n    console.print(f\"[bold]\ud83d\udcc1 Path:[/bold] {Path(path).resolve()}\\n\")\n\n    # Default: table format\n    for section in results:\n        console.print(Text.assemble(\"\\n\", format_result(section[\"status\"]), \" \", (section[\"title\"], \"bold\")))\n\n        if section[\"status\"] == \"pass\":\n            passed += 1\n        else:\n            failed += 1\n\n        for item in section[\"items\"]:\n            label = item[\"label\"]\n            value = item[\"value\"]\n            status = item[\"status\"]\n\n            line = Text.assemble(\n                (\"  \u2022 \", \"default\"),\n                (label, \"dim\"),\n                (\": \", \"default\"),\n                format_detail(status, value),\n            )\n            console.print(line)\n\n            if verbose and status != \"pass\":\n                if item.get(\"hint\"):\n                    console.print(f\"    \u21aa [yellow]{item['hint']}[/yellow]\")\n                hint_url = item.get(\"hint_url\", \"\")\n                if hint_url.strip():\n                    console.print(f\"    \ud83d\udcda [blue]{hint_url}[/blue]\")\n\n    # \u2705 Summary section\n    console.print()\n    console.print(\"[bold]Summary[/bold]\")\n    summary = Text.assemble(\n        (f\"{format_status_icon('pass')} \", \"green bold\"),\n        (f\"{passed} Passed    \", \"bold\"),\n        (f\"{format_status_icon('fail')} \", \"red bold\"),\n        (f\"{failed} Failed\", \"bold\"),\n    )\n    console.print(summary)\n</code></pre>"},{"location":"api/#doctor","title":"Doctor","text":""},{"location":"api/#azure_functions_doctor.doctor.Doctor","title":"<code>Doctor(path='.')</code>","text":"<p>Diagnostic runner for Azure Functions apps. Loads checks from rules.json and executes them against a target project path.</p> Source code in <code>src/azure_functions_doctor/doctor.py</code> <pre><code>def __init__(self, path: str = \".\") -&gt; None:\n    self.project_path: Path = Path(path).resolve()\n</code></pre>"},{"location":"api/#handlers","title":"Handlers","text":""},{"location":"api/#azure_functions_doctor.handlers.generic_handler","title":"<code>generic_handler(rule, path)</code>","text":"<p>Execute a diagnostic rule based on its type and condition.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Rule</code> <p>The diagnostic rule to execute.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary with the status and detail of the check.</p> Source code in <code>src/azure_functions_doctor/handlers.py</code> <pre><code>def generic_handler(rule: Rule, path: Path) -&gt; dict[str, str]:\n    \"\"\"\n    Execute a diagnostic rule based on its type and condition.\n\n    Args:\n        rule: The diagnostic rule to execute.\n\n    Returns:\n        A dictionary with the status and detail of the check.\n    \"\"\"\n    check_type = rule.get(\"type\")\n    condition = rule.get(\"condition\", {})\n\n    target = condition.get(\"target\")\n    operator = condition.get(\"operator\")\n    value = condition.get(\"value\")\n\n    # Compare current Python version with expected version\n    if check_type == \"compare_version\":\n        if not (target and operator and value):\n            return {\"status\": \"fail\", \"detail\": \"Missing condition fields for compare_version\"}\n\n        if target == \"python\":\n            current_version = f\"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}\"\n            current = parse_version(current_version)\n            expected = parse_version(str(value))\n            passed = {\n                \"&gt;=\": current &gt;= expected,\n                \"&lt;=\": current &lt;= expected,\n                \"==\": current == expected,\n                \"&gt;\": current &gt; expected,\n                \"&lt;\": current &lt; expected,\n            }.get(operator, False)\n            return {\n                \"status\": \"pass\" if passed else \"fail\",\n                \"detail\": f\"Python version is {current_version}, expected {operator}{value}\",\n            }\n\n        return {\"status\": \"fail\", \"detail\": f\"Unknown target for version comparison: {target}\"}\n\n    # Check if an environment variable is set\n    if check_type == \"env_var_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing environment variable name\"}\n\n        exists = os.getenv(target) is not None\n        return {\n            \"status\": \"pass\" if exists else \"fail\",\n            \"detail\": f\"{target} is {'set' if exists else 'not set'}\",\n        }\n\n    # Check if a path exists (including sys.executable)\n    if check_type == \"path_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing target path\"}\n\n        resolved_path = sys.executable if target == \"sys.executable\" else os.path.join(path, target)\n        exists = os.path.exists(resolved_path)\n\n        if exists:\n            return {\"status\": \"pass\", \"detail\": f\"{resolved_path} exists\"}\n\n        if not rule.get(\"required\", True):\n            return {\"status\": \"pass\", \"detail\": f\"{resolved_path} is missing (optional)\"}\n\n        return {\"status\": \"fail\", \"detail\": f\"{resolved_path} is missing\"}\n\n    # Check if a specific file exists\n    if check_type == \"file_exists\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing file path\"}\n\n        file_path = os.path.join(path, target)\n        exists = os.path.isfile(file_path)\n\n        if exists:\n            return {\"status\": \"pass\", \"detail\": f\"{file_path} exists\"}\n\n        if not rule.get(\"required\", True):\n            return {\"status\": \"pass\", \"detail\": f\"{file_path} not found (optional for local development)\"}\n\n        return {\"status\": \"fail\", \"detail\": f\"{file_path} not found\"}\n\n    # Check if a Python package is importable\n    if check_type == \"package_installed\":\n        if not target:\n            return {\"status\": \"fail\", \"detail\": \"Missing package name\"}\n\n        import_path_str: str = str(target)\n\n        try:\n            __import__(import_path_str)\n            found = True\n            error_msg = \"\"\n        except ImportError as exc:\n            found = False\n            error_msg = f\": {exc}\"\n\n        return {\n            \"status\": \"pass\" if found else \"fail\",\n            \"detail\": f\"Module '{import_path_str}' is {'installed' if found else f'not installed{error_msg}'}\",\n        }\n\n    # Check if a keyword exists in any .py source files\n    if check_type == \"source_code_contains\":\n        keyword = condition.get(\"keyword\")\n        if not isinstance(keyword, str):\n            return {\n                \"status\": \"fail\",\n                \"detail\": \"Missing or invalid 'keyword' in condition\",\n            }\n\n        found = False\n\n        for py_file in path.rglob(\"*.py\"):\n            try:\n                content = py_file.read_text(encoding=\"utf-8\")\n                if keyword in content:\n                    found = True\n                    break\n            except Exception:\n                continue\n\n        return {\n            \"status\": \"pass\" if found else \"fail\",\n            \"detail\": f\"Keyword '{keyword}' {'found' if found else 'not found'} in source code\",\n        }\n\n    # Unknown check type fallback\n    return {\"status\": \"fail\", \"detail\": f\"Unknown check type: {check_type}\"}\n</code></pre>"},{"location":"api/#check-logic","title":"Check Logic","text":""},{"location":"api/#azure_functions_doctor.check.run_check","title":"<code>run_check(rule, base_path)</code>","text":"<p>Wrap the generic_handler to cast a raw rule into a typed Rule.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>dict[str, Any]</code> <p>Dictionary parsed from rules.json</p> required <code>base_path</code> <code>Path</code> <p>Path to Azure Functions app</p> required <p>Returns:</p> Type Description <code>CheckResult</code> <p>Structured result with status, label, value, and optional hint.</p> Source code in <code>src/azure_functions_doctor/check.py</code> <pre><code>def run_check(rule: dict[str, Any], base_path: Path) -&gt; CheckResult:\n    \"\"\"\n    Wrap the generic_handler to cast a raw rule into a typed Rule.\n\n    Args:\n        rule: Dictionary parsed from rules.json\n        base_path: Path to Azure Functions app\n\n    Returns:\n        Structured result with status, label, value, and optional hint.\n    \"\"\"\n    typed_rule = cast(Rule, rule)\n    result = generic_handler(typed_rule, base_path)\n\n    output: CheckResult = {\n        \"status\": result[\"status\"],\n        \"label\": typed_rule.get(\"label\", typed_rule[\"id\"]),\n        \"value\": result[\"detail\"],\n    }\n\n    if \"hint\" in typed_rule:\n        output[\"hint\"] = typed_rule[\"hint\"]\n\n    return output\n</code></pre>"},{"location":"api/#target-resolver","title":"Target Resolver","text":""},{"location":"api/#azure_functions_doctor.target_resolver.resolve_target_value","title":"<code>resolve_target_value(target)</code>","text":"<p>Resolve the current value of a target used in version comparison or diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string representing the resolved version or value.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the target is not recognized.</p> Source code in <code>src/azure_functions_doctor/target_resolver.py</code> <pre><code>def resolve_target_value(target: str) -&gt; str:\n    \"\"\"\n    Resolve the current value of a target used in version comparison or diagnostics.\n\n    Args:\n        target: The name of the target to resolve. Examples include \"python\" or \"func_core_tools\".\n\n    Returns:\n        A string representing the resolved version or value.\n\n    Raises:\n        ValueError: If the target is not recognized.\n    \"\"\"\n    if target == \"python\":\n        return sys.version.split()[0]\n    if target == \"func_core_tools\":\n        try:\n            output = subprocess.check_output([\"func\", \"--version\"], text=True)\n            return output.strip()\n        except Exception:\n            return \"0.0.0\"  # Return a fallback version if resolution fails\n    raise ValueError(f\"Unknown target: {target}\")\n</code></pre>"},{"location":"api/#utility","title":"Utility","text":""},{"location":"api/#azure_functions_doctor.utils.format_detail","title":"<code>format_detail(status, value)</code>","text":"<p>Return a colored Text element based on status and value.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <code>value</code> <code>str</code> <p>Text to display, typically a description.</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object styled with status color.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_detail(status: str, value: str) -&gt; Text:\n    \"\"\"\n    Return a colored Text element based on status and value.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n        value: Text to display, typically a description.\n\n    Returns:\n        A Rich Text object styled with status color.\n    \"\"\"\n    color = DETAIL_COLOR_MAP.get(status, \"white\")\n    return Text(value, style=color)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_result","title":"<code>format_result(status)</code>","text":"<p>Return a styled icon Text element based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>Text</code> <p>A Rich Text object with icon and style for headers.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_result(status: str) -&gt; Text:\n    \"\"\"\n    Return a styled icon Text element based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A Rich Text object with icon and style for headers.\n    \"\"\"\n    style = STATUS_STYLES.get(status, Style(color=\"white\"))\n    icon = format_status_icon(status)\n    return Text(icon, style=style)\n</code></pre>"},{"location":"api/#azure_functions_doctor.utils.format_status_icon","title":"<code>format_status_icon(status)</code>","text":"<p>Return a simple icon character based on status.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>str</code> <p>Diagnostic status (\"pass\", \"fail\", \"warn\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string icon such as \u2714, \u2716, or \u26a0.</p> Source code in <code>src/azure_functions_doctor/utils.py</code> <pre><code>def format_status_icon(status: str) -&gt; str:\n    \"\"\"\n    Return a simple icon character based on status.\n\n    Args:\n        status: Diagnostic status (\"pass\", \"fail\", \"warn\").\n\n    Returns:\n        A string icon such as \u2714, \u2716, or \u26a0.\n    \"\"\"\n    return STATUS_ICONS.get(status, \"?\")\n</code></pre>"},{"location":"development/","title":"\ud83d\udee0\ufe0f Development Guide (Hatch-based)","text":"<p>This guide covers how to set up a local development environment, run tests, and manage code quality for Azure Functions Doctor, using Hatch and a Makefile for workflow automation.</p>"},{"location":"development/#prerequisites","title":"\ud83d\udce6 Prerequisites","text":"<ul> <li>Python 3.9+ installed on your system</li> <li>Git for version control</li> <li>Hatch as the build and environment manager (installed via <code>pip install hatch</code>)</li> <li>Make (for running the provided Makefile targets)</li> <li>(Optional) uv for fast dependency installation (<code>pip install uv</code>)</li> </ul>"},{"location":"development/#project-structure-overview","title":"\ud83d\udee0\ufe0f Project Structure Overview","text":"<pre><code>azure-functions-doctor-for-python/\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 hatch.toml\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 azure_functions_doctor/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u251c\u2500\u2500 cli.py\n\u2502       \u251c\u2500\u2500 doctor.py\n\u2502       \u251c\u2500\u2500 handlers.py\n\u2502       \u251c\u2500\u2500 utils.py\n\u2502       \u251c\u2500\u2500 assets/\n\u2502       \u2502   \u2514\u2500\u2500 rules.json\n\u2502       \u2514\u2500\u2500 checks/\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_cli.py\n\u2502   \u251c\u2500\u2500 test_handler.py\n\u2502   \u2514\u2500\u2500 test_*.py\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md\n\u2502   \u251c\u2500\u2500 usage.md\n\u2502   \u251c\u2500\u2500 rules.md\n\u2502   \u251c\u2500\u2500 diagnostics.md\n\u2502   \u2514\u2500\u2500 development.md\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 basic-hello/\n\u2502       \u2514\u2500\u2500 diagnose-output.md\n\u2514\u2500\u2500 ...\n</code></pre> <ul> <li><code>Makefile</code>: Defines common commands for creating the environment, running tests, linting, formatting, and publishing.</li> <li><code>pyproject.toml</code> and <code>hatch.toml</code>: Configuration for Hatch environments and project metadata.</li> <li><code>src/azure_functions_doctor/</code>: Core application code, including CLI entrypoint, diagnostic logic, and rule assets.</li> <li><code>tests/</code>: Unit and integration tests for the project.</li> <li><code>docs/</code>: Documentation files used by MkDocs (if enabled) or GitHub pages.</li> <li><code>examples/</code>: Contains sample Azure Functions projects and expected outputs.</li> </ul>"},{"location":"development/#initial-setup","title":"\ud83d\ude80 Initial Setup","text":"<ol> <li> <p>Clone the repository:     <code>bash     git clone https://github.com/yeongseon/azure-functions-doctor-for-python.git     cd azure-functions-doctor-for-python</code></p> </li> <li> <p>Create and activate a virtual environment using the Makefile:     <code>bash     make venv     source .venv/bin/activate      # On Windows (PowerShell): .venv\\Scripts\\Activate.ps1</code></p> </li> <li> <p>Install project dependencies via Hatch (or using <code>uv</code> if preferred):     <code>bash     make install     # or, if using uv: uv install</code></p> </li> <li> <p>Install pre-commit hooks for code formatting and linting:     <code>bash     make precommit-install</code></p> </li> </ol> <p>Note: The Makefile ensures Hatch commands run inside the appropriate environment. If you bypass Makefile, you can manually do: <code>bash hatch env create default hatch run pip install -r requirements-dev.txt hatch run pre-commit install</code></p>"},{"location":"development/#running-tests-and-quality-checks","title":"\ud83e\uddea Running Tests and Quality Checks","text":""},{"location":"development/#1-format-code","title":"1. Format Code","text":"<p>Use Black and Ruff via Makefile to enforce consistent styling:</p> <pre><code>make format\n</code></pre>"},{"location":"development/#2-lint-code","title":"2. Lint Code","text":"<p>Run Ruff and Mypy for linting and type checks:</p> <pre><code>make lint\n</code></pre>"},{"location":"development/#3-type-checking","title":"3. Type Checking","text":"<p>Perform static type analysis with Mypy:</p> <pre><code>make typecheck\n</code></pre>"},{"location":"development/#4-run-unit-tests","title":"4. Run Unit Tests","text":"<p>Execute all tests using pytest:</p> <pre><code>make test\n</code></pre>"},{"location":"development/#5-combined-quality-checks","title":"5. Combined Quality Checks","text":"<p>Run formatting, linting, type checking, and tests in one command:</p> <pre><code>make check\n</code></pre>"},{"location":"development/#6-generate-coverage-report","title":"6. Generate Coverage Report","text":"<p>Produce a coverage report (HTML + XML):</p> <pre><code>make cov\n</code></pre> <ul> <li>Opens <code>htmlcov/index.html</code> for browser viewing</li> <li>Generates <code>coverage.xml</code> for CI integrations (e.g., Codecov)</li> </ul>"},{"location":"development/#development-workflow","title":"\ud83c\udfaf Development Workflow","text":"<ol> <li> <p>Create a feature branch:     <code>bash     git checkout -b feature/your-description</code></p> </li> <li> <p>Implement changes in <code>src/azure_functions_doctor/</code> and/or update <code>rules.json</code> under <code>src/azure_functions_doctor/assets/</code>.</p> </li> <li> <p>Add new tests in the <code>tests/</code> directory to cover your changes.</p> </li> <li> <p>Run quality checks locally:     <code>bash     make check</code></p> </li> <li> <p>Commit changes with Conventional Commits format:     <code>git commit -m \"feat: add new check for custom config file\"</code></p> </li> <li> <p>Push and open a Pull Request to <code>main</code>.</p> </li> </ol>"},{"location":"development/#makefile-targets-reference","title":"\ud83d\udcdd Makefile Targets Reference","text":"Target Description <code>make venv</code> Create a Python virtual environment at <code>.venv/</code> <code>make install</code> Install runtime and dev dependencies via Hatch (<code>hatch install</code>) <code>make precommit-install</code> Install pre-commit hooks (Black, Ruff, etc.) <code>make format</code> Format code with Black and apply Ruff fixes <code>make lint</code> Run Ruff and Mypy checks <code>make typecheck</code> Perform static type checking with Mypy <code>make test</code> Run pytest <code>make check</code> Run formatting, linting, typechecking, and tests in sequence <code>make cov</code> Generate coverage report and open HTML index <code>make docs</code> Serve MkDocs locally (if MkDocs configured) <code>make release-patch</code> Bump patch version, update changelog <code>make release-minor</code> Bump minor version, update changelog <code>make release-major</code> Bump major version, update changelog <code>make publish</code> Publish package to PyPI (requires credentials in environment) <p>For detailed release workflow, refer to <code>release_process.md</code>.</p>"},{"location":"development/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>We welcome contributions! Please follow these steps:</p> <ol> <li>Fork the repository and create a new branch.</li> <li>Follow the Development Workflow above.</li> <li>Ensure tests pass and code quality checks succeed.</li> <li>Submit a Pull Request with a clear description of your changes.</li> </ol> <p>Thank you for helping improve Azure Functions Doctor!</p>"},{"location":"development/#license","title":"\ud83d\udcc4 License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"diagnostics/","title":"Diagnostics","text":""},{"location":"diagnostics/#diagnostic-checks-updated-for-azure-functions-python-programming-model-v2","title":"\ud83d\ude7a Diagnostic Checks (Updated for Azure Functions Python Programming Model v2)","text":"<p>This document lists diagnostic checks for Azure Functions Doctor, based on Azure Functions Python Reference and Best Practices.</p> # Diagnostic Check Description Feasibility Status 1 Python version \u2265 3.9 Check if the runtime meets minimum requirements \u2705 Easy \u2705 Implemented 2 Virtual environment (.venv) active Ensure Python environment is isolated via virtualenv \u2705 Easy \u2705 Implemented 3 Azure Functions Core Tools installed Validate that <code>func</code> CLI is installed and accessible \u2705 Easy \u2705 Implemented 4 <code>host.json</code> exists Required runtime configuration file must be present \u2705 Easy \u2705 Implemented 5 <code>requirements.txt</code> exists Check for dependency management file \u2705 Easy \u2705 Implemented 6 <code>azure-functions</code> package installed Ensure required Azure Functions SDK is installed \u2705 Easy \u2705 Implemented 7 <code>azure-functions-python-library</code> installed Required for Programming Model v2 decorator syntax \u2705 Easy \u2705 Implemented 8 <code>local.settings.json</code> exists (optional) Useful for storing app settings locally \u2705 Easy \ud83d\udd27 Planned 9 Detect use of decorators Confirm use of v2-style decorators like <code>@function_name</code> \u2705 Easy \u2705 Implemented 10 Function mode detection (v1 vs v2) Detect whether app uses function.json or decorators \u2705 Medium \ud83d\udd27 Planned 11 Directory structure validation Warn if folder structure is non-standard or missing expected files \u2705 Easy \u2705 Implemented 12 Durable Functions config in <code>host.json</code> Check for presence of <code>durableTask</code> section \u2705 Medium \ud83d\udd27 Planned 13 HTTP trigger validation Ensure <code>authLevel</code>, <code>methods</code>, <code>route</code> in binding are valid \u2705 Medium \ud83d\udd27 Planned 14 Timer trigger CRON validation Validate correct CRON format \u2705 Medium \ud83d\udd27 Planned 15 App Insights configuration Validate presence of instrumentation key or connection string \u2705 Medium \ud83d\udd27 Planned 16 EntryPoint in <code>function.json</code> (v1 only) Check if entryPoint matches a real function (v1 only) \u2705 Easy \u274c Not needed 17 Function name and folder match (v1 only) Ensure folder/function naming aligns (v1 only) \u2705 Easy \u274c Not needed 18 ASGI/WSGI compatibility Check if app exposes ASGI/WSGI callable \u2705 Medium \ud83d\udd27 Planned 19 Detect unused or invalid files Warn about <code>.pyc</code>, <code>__pycache__</code>, or legacy files \u2705 Low \ud83d\udd1d Possible 20 Detect long-running blocking patterns Detect <code>sleep()</code>, infinite loops, or sync IO blocking \u274c Hard \u274c Not feasible 21 Excessive logging Detect overuse of <code>print()</code> or <code>logging.debug()</code> \u274c Runtime \u274c Not feasible 22 Monolithic layout warning Detect if everything is in one large file \u274c Context \u274c Not feasible <p>Legend: \u2705 Easy = statically checkable \u2705 Medium = requires additional parsing/context \u274c = not feasible by static analysis \ud83d\udd27 Planned = scheduled for future implementation \ud83e\udded Possible = technically feasible but lower priority</p>"},{"location":"diagnostics/#key-changes","title":"\u2705 Key Changes","text":"<ul> <li>Removed <code>main.py</code> check (was v1 specific)</li> <li>Added decorator detection (v2 model confirmation)</li> <li>Excluded v1-only checks like <code>entryPoint</code>, <code>function.json</code> folder matching</li> <li>Included v2-only checks like <code>azure-functions-python-library</code></li> <li>Clarified feasibility and implementation status across all checks</li> </ul>"},{"location":"release_process/","title":"\ud83d\udee0\ufe0f Release Process","text":"<p>This document outlines the steps to release a new version of Azure Functions Doctor to PyPI and update the changelog, using the existing Makefile and Hatch-based workflows.</p>"},{"location":"release_process/#step-1-bump-version-and-generate-changelog","title":"\ud83e\uddfe Step 1: Bump Version and Generate Changelog","text":"<p>Use the Makefile targets to bump the version and update the changelog:</p> <pre><code># Patch release (e.g., v0.1.0 \u2192 v0.1.1)\nmake release-patch\n\n# Minor release (e.g., v0.1.1 \u2192 v0.2.0)\nmake release-minor\n\n# Major release (e.g., v0.2.0 \u2192 v1.0.0)\nmake release-major\n</code></pre> <p>Each command will: - Update the version in <code>pyproject.toml</code> and <code>src/azure_functions_doctor/__init__.py</code> - Generate or update <code>CHANGELOG.md</code> based on Git commit history (<code>git-cliff</code>) - Commit the updated changelog and version bump - Create a Git tag (e.g., <code>v0.2.0</code>) - Push commits and tags to the <code>main</code> branch</p> <p>Tip: Ensure your local branch is up-to-date with <code>main</code> before running these commands.</p>"},{"location":"release_process/#step-2-build-and-test-the-package","title":"\ud83d\udce6 Step 2: Build and Test the Package","text":"<p>Before publishing, build and verify locally:</p> <pre><code># Create source and wheel distributions\nmake build\n\n# (Optional) Install from the local distribution to test\npip install dist/azure_functions_doctor-&lt;version&gt;-py3-none-any.whl\n</code></pre> <p>Verify installation:</p> <pre><code>func-doctor --version\n</code></pre>"},{"location":"release_process/#step-3-publish-to-pypi","title":"\ud83d\ude80 Step 3: Publish to PyPI","text":"<p>Once the build artifacts are validated, upload the package to PyPI:</p> <pre><code>make publish\n</code></pre> <p>This runs: - <code>hatch release</code> under the hood (builds, signs if configured, and uploads) - Uses credentials from <code>~/.pypirc</code> or environment variables (<code>PYPI_USERNAME</code>/<code>PYPI_PASSWORD</code>) - Verifies successful upload by checking PyPI listing</p> <p>Security: Ensure that your PyPI API token or credentials are stored securely and not committed to source control.</p>"},{"location":"release_process/#step-4-test-on-testpypi-optional","title":"\ud83d\udd01 Step 4: Test on TestPyPI (Optional)","text":"<p>If you want to verify the upload workflow without affecting production releases:</p> <ol> <li>Build the package:</li> </ol> <p><code>bash    make build</code></p> <ol> <li>Upload to TestPyPI:</li> </ol> <p><code>bash    twine upload --repository testpypi dist/*</code></p> <ol> <li>Install from TestPyPI:</li> </ol> <p><code>bash    pip install --index-url https://test.pypi.org/simple/ azure-functions-doctor</code></p> <ol> <li>Verify version:</li> </ol> <p><code>bash    func-doctor --version</code></p>"},{"location":"release_process/#summary-of-release-commands","title":"\u2705 Summary of Release Commands","text":"Task Command Version bump + changelog <code>make release-patch</code> Build distributions <code>make build</code> Publish to PyPI <code>make publish</code> Test on TestPyPI (optional) <code>twine upload --repository testpypi dist/*</code>"},{"location":"release_process/#related-documentation","title":"\ud83d\udd17 Related Documentation","text":"<ul> <li>CHANGELOG.md</li> <li>Development Guide</li> <li>Makefile Targets</li> <li>PyPI Publishing with Hatch</li> </ul>"},{"location":"rules/","title":"\ud83d\udcd8 <code>rules.json</code> Documentation","text":"<p>The <code>rules.json</code> file defines diagnostic checks declaratively for Azure Functions Doctor. Each rule specifies what to validate, how to validate it, and what to show when the check passes or fails \u2014 without modifying the core Python code.</p> <p>This makes the tool extensible and customizable.</p>"},{"location":"rules/#location","title":"\ud83d\udcc1 Location","text":"<p>The file is located under the assets/ directory:</p> <pre><code>src/\n\u2514\u2500\u2500 azure_functions_doctor/\n    \u2514\u2500\u2500 assets/\n        \u2514\u2500\u2500 rules.json  \ud83d\udc48\n</code></pre>"},{"location":"rules/#structure-of-a-rule","title":"\u2310 Structure of a Rule","text":"<p>Each rule is a JSON object with the following fields:</p> <pre><code>{\n  \"id\": \"check_python_version\",\n  \"section\": \"python_env\",\n  \"label\": \"Python version\",\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\",\n  \"hint\": \"Install Python 3.9 or higher.\"\n}\n</code></pre>"},{"location":"rules/#fields-explained","title":"\ud83d\udd11 Fields Explained","text":"Field Type Description <code>id</code> string Unique identifier for the rule <code>section</code> string Logical group (e.g. <code>python_env</code>, <code>config_files</code>) <code>label</code> string Human-readable label for the check <code>type</code> string Rule type (see below) <code>target</code> string Subject to evaluate (e.g. Python version, file path) <code>operator</code> string Comparison operator (e.g. <code>==</code>, <code>!=</code>, <code>&gt;=</code>) <code>value</code> any Expected value to compare <code>hint</code> string Suggestion if the rule fails"},{"location":"rules/#supported-rule-types","title":"\ud83d\udd0d Supported Rule Types","text":""},{"location":"rules/#1-compare_version","title":"1. <code>compare_version</code>","text":"<p>Compare semantic versions.</p> <pre><code>{\n  \"type\": \"compare_version\",\n  \"target\": \"python\",\n  \"operator\": \"&gt;=\",\n  \"value\": \"3.9\"\n}\n</code></pre> <ul> <li>Valid <code>target</code>: <code>\"python\"</code>, <code>\"azure-functions-core-tools\"</code></li> </ul>"},{"location":"rules/#2-file_exists","title":"2. <code>file_exists</code>","text":"<p>Check whether a file exists.</p> <pre><code>{\n  \"type\": \"file_exists\",\n  \"target\": \"host.json\"\n}\n</code></pre>"},{"location":"rules/#3-file_contains","title":"3. <code>file_contains</code>","text":"<p>Check whether a file contains a specific string or key path.</p> <pre><code>{\n  \"type\": \"file_contains\",\n  \"target\": \"host.json\",\n  \"key_path\": [\"version\"],\n  \"value\": \"2.0\"\n}\n</code></pre>"},{"location":"rules/#4-custom","title":"4. <code>custom</code>","text":"<p>You may register custom handlers in code using the <code>@handler.register(\"your_type\")</code> decorator. Add a <code>\"type\": \"custom\"</code> field and let your handler interpret additional keys under <code>condition</code>.</p>"},{"location":"rules/#grouping-by-section","title":"\ud83d\udcc1 Grouping by <code>section</code>","text":"<p>Sections allow grouping related checks together for better readability in the CLI output:</p> <p>Example:</p> <pre><code>{\n  \"section\": \"python_env\",\n  \"label\": \"Python Version\",\n  ...\n}\n</code></pre> <p>Predefined sections might include:</p> <ul> <li><code>python_env</code></li> <li><code>core_tools</code></li> <li><code>config_files</code></li> <li><code>dependencies</code></li> <li><code>network</code></li> </ul> <p>You can create your own section names if desired.</p>"},{"location":"rules/#extending-the-rules","title":"\ud83e\uddf9 Extending the Rules","text":"<p>To add a new rule:</p> <ol> <li>Open <code>src/azure_functions_doctor/assets/rules.json</code></li> <li>Append your rule object to the array</li> <li>Save and rerun <code>func-doctor</code></li> </ol> <p>Example:</p> <pre><code>{\n  \"id\": \"check_requirements_txt_exists\",\n  \"section\": \"dependencies\",\n  \"label\": \"requirements.txt exists\",\n  \"type\": \"file_exists\",\n  \"target\": \"requirements.txt\",\n  \"hint\": \"Create a requirements.txt file to declare Python dependencies.\"\n}\n</code></pre>"},{"location":"rules/#tips","title":"\ud83d\udee0\ufe0f Tips","text":"<ul> <li>Use <code>hint</code> to provide helpful, actionable suggestions.</li> <li>Use consistent <code>section</code> names for better CLI grouping.</li> <li>If you're writing custom rule types, register them in <code>handlers.py</code>.</li> </ul>"},{"location":"rules/#testing-your-changes","title":"\ud83e\udd6a Testing Your Changes","text":"<p>After editing <code>rules.json</code>, you can run:</p> <pre><code>func-doctor diagnose --verbose\n</code></pre> <p>To see grouped results and hints.</p>"},{"location":"rules/#example-rulesjson-simplified","title":"\ud83d\udcdf Example <code>rules.json</code> (simplified)","text":"<pre><code>[\n  {\n    \"id\": \"check_python_version\",\n    \"section\": \"python_env\",\n    \"label\": \"Python version\",\n    \"type\": \"compare_version\",\n    \"target\": \"python\",\n    \"operator\": \"&gt;=\",\n    \"value\": \"3.9\",\n    \"hint\": \"Install Python 3.9 or higher.\"\n  },\n  {\n    \"id\": \"check_host_json_exists\",\n    \"section\": \"config_files\",\n    \"label\": \"host.json exists\",\n    \"type\": \"file_exists\",\n    \"target\": \"host.json\"\n  }\n]\n</code></pre>"},{"location":"rules/#contribute-new-rules","title":"\ud83d\udcec Contribute New Rules","text":"<p>Want to improve the default rules? Feel free to open a PR or discussion on \ud83d\udc49 GitHub Repository</p>"},{"location":"usage/","title":"\ud83d\udda5\ufe0f CLI Usage: <code>func-doctor</code>","text":"<p>The Azure Functions Doctor CLI helps validate your local Python-based Azure Functions project for common issues using an extensible rules system.</p>"},{"location":"usage/#basic-usage","title":"\ud83d\ude80 Basic Usage","text":"<pre><code>func-doctor diagnose\n</code></pre> <p>Run diagnostics in the current or specified folder.</p>"},{"location":"usage/#options","title":"\u2699\ufe0f Options","text":"Option Description <code>--path</code> Target directory (default: current folder) <code>--format json</code> Output in machine-readable JSON <code>--verbose</code> Show detailed diagnostics and hints <code>--help</code> Show usage for the CLI or subcommand <p>Example:</p> <pre><code>func-doctor diagnose --path ./my-func-app --format json --verbose\n</code></pre>"},{"location":"usage/#what-it-checks","title":"\u2705 What It Checks","text":"Category Description Python Environment Python version \u2265 3.9, virtualenv activated, executable exists Dependencies <code>requirements.txt</code> present, <code>azure-functions</code> installed Project Files <code>host.json</code>, <code>local.settings.json</code>, and <code>main.py</code> exist"},{"location":"usage/#example-output","title":"\ud83e\uddea Example Output","text":"<pre><code>\ud83e\ude7a Azure Functions Doctor for Python v0.1.0\n\ud83d\udcc1 Path: /root/Github/azure-functions-doctor/examples/basic-hello\n\n\u2716 Python Env\n  \u2022 Python version: Python version is 3.12.3, expected &gt;=3.9\n  \u2022 Virtual environment: VIRTUAL_ENV is set\n  \u2022 Python executable: .../bin/python exists\n  \u2022 requirements.txt: exists\n  \u2022 azure-functions package: Package 'azure_functions' is not installed\n\n\u2716 Project Structure\n  \u2022 host.json: exists\n  \u2022 local.settings.json: is missing\n  \u2022 main.py: is missing\n\nSummary\n\u2714 0 Passed    \u2716 2 Failed\n</code></pre>"},{"location":"usage/#help","title":"\ud83c\udd98 Help","text":"<pre><code>func-doctor --help\nfunc-doctor diagnose --help\n</code></pre> <p>For more examples, see the example project.</p>"}]}